# コーディングルール（全言語共通）

## 変数について

- マジックナンバーやマジックストリングを避けること
- 名前付き定数を積極的に使い何の値かを表現すること
- 基本的にはプログラミング言語が用意している不変を宣言する構文を利用する
    - 例えば、JavaScriptの場合は`let`や`var`がサポートされているが、値の更新が必要ではないケースでは`const`を優先して使うこと。
    - どんな構文が使えるか学習済みのプログラミング言語の仕様を元に判断すること。
    - 何を使えば良いか判断が難しい場合は、無理に検討せず、素直に質問すること。

```typescript
// bad
var name = 'okabe';
let name = 'okabe';

// good
const name = 'okabe';
```


## 命名について

- 明確でわかりやすい名前をつける
    - ループカウンタ（`i`, `j`）やよく知られた慣習（`e` でエラー、`_` で未使用）を除き、1文字の変数は避ける。
- 真偽値の変数・関数は疑問形で読めるようにする: `isValid`, `hasPermission`, `canDelete`。
- 否定を否定するような命名はしないこと

```typescript
// bad
const notExcludeUserIds = [1,2,3];

// good
const includeUserIds = [1,2,3];
```

- 明確な命名をする一方で、変数名が30文字を超えるケースについては素直に質問すること
- より良い命名がないか（`hogeConvertToFoo`は`toFoo`で良かったりする）は必ず検討すること
- またプロジェクト内部で同じニュアンスで命名がされている場合、そちらを優先すること
    統一感がないと理解が難解になるため、既存の命名に合わせるようにすること


## 関数について

### 引数と戻り値

- 引数の数が4つを超える場合は専用のinput型を宣言したり、オブジェクトを使うことを検討すること。
- 戻り値についても同様に検討すること
    - 複雑なデータ型を返す場合は、専用の型を宣言するか、言語が提供していれば`alias`を使うこと
    - 言語によって適切なデータ構造は異なるため、判断が難しい場合は素直に質問をすること

```kotlin
// bad
// 構造が煩雑で意図が分からず、型でどんな情報が含まれているか判断しにくい
fun hoge(...): Pair<List<String>, Pair<String, Int>>

// good
data class Hoge(
    list: List<String>,
    pair: Pair<String, Int>,
)

fun hoge(...): Hoge
```

### 関数の長さ

- なるべく短く保つようにすること。しかし無理に別の関数に切り出す必要はない。
- 処理の責務を検討して適切な関数単位を意識すること
    - 特に副作用（例: データベースへの書き込み）が発生するような場合には、中途半端に関数単位を分割して、処理を追うのが難しくならないようにすること
    - 例えば、サービスクラスが外部に1つパブリックなメソッドを公開して、そこで副作用を発生するようにすることで、読み手に何が起きるかを明確に伝わるようにしておくと良い

```kotlin
// kotlin の場合
class HogeService(...) {
    fun exec(...) {
        // do something

        // effect
        val savedValues = hogeRepository.save(...)
    }
}
```

- `private`関数から`private`関数をネストして呼び出すことは基本的にしないこと。２層までは許容範囲。
- 積極的に早期リターンやガード節を使い、コードブロックのネストが浅くなるように保つこと
- 早すぎる抽象化をしない。明確なパターンが見えるまで重複は許容する（Rule of Three）

### テスト実行性

- 関数がロジックを持つ場合は単体テストの対象とすること
- またテスト実行のしやすさ・単位について気をつけて関数を作成すること
    - テストをする必要があると判断できる場合、関数として知識を切り出し単体テストが実行できるようにしておくこと


## コメントについて

- 積極的に書くことを推奨する。しかし、何をしているかのコメントは基本的に書かず設計の意図や目的を書くこと
- 1つの処理のコード行が長くなるような場合は読み手の負荷を下げるために、ステップNのようなコメントを書いておくこと

```typescript
/**
 * hogeをhooするための関数。
 *
 * step:
 * 1: データをフェッチして変換処理を行う
 * 2: 変換したデータを元に...
 */
function hoge(...) {
    // 1. データをフェッチして変換処理を行う

    // 2. 変換したデータを元に...
}
```

- クラスや関数には言語がサポートしている`doc`形式（例: kotlinの場合kdoc）を記載して、何をする処理なのかを簡潔に記載すること
- `TODO`や`FYI`などのプレフィックスを積極的に活用すること
    - またプレフィックスを使用する場合はタイムスタンプを記載しておくこと

```typescript
// TODO: 20260207
// この処理は....
```

## 原理原則について

- デメテルの法則に従うこと
    - 詳細はdddに関する別ルールを参照
- DRY(Don't Repeat Yourself）に従うこと
    - ただし過剰な共通化は可読性を低下させるため避けること。判断が難しい場合は質問すること
- シンプルかつYAGNIであること
    - 過度な共通化やDSL化は初期のバージョンでは避けること
    - DSL化を検討した方が良い場合などは、質問すること
- SOLIDの原則に従うこと
    - ただし過度なインターフェースの使用は避けること
- 密結合を避けてロジックを集約して凝縮度を高めること
    - 凝縮度に関しての詳細はdddに関する別ルールを参照


## エラーハンドリングについて

- エラーを握りつぶさない。最低限ログに出力すること
- エラーをハンドリングして呼び手側で何かしたい場合、エラーを型として表現すること
- `raise`された例外が呼び手側で、どう扱われているかについて注意をすること
    - 何もハンドリングされていない場合、質問をすること


## セキュリティについて

- シークレット、認証情報、APIキーをハードコードしない
- `eval()` や同等の動的コード実行を使わない
- 外部入力はシステム境界で必ずサニタイズする


## パフォーマンスについて

- ループ処理を実行する場合、ループされる回数に注意すること
    - 計算量オーダーについて意識をすること
    - 配列から全探索するようなケースでは、`Map`(kotlinの場合)を作成して、O(1)でデータを取得するのが望ましい
- DBクエリを扱う場合、N+1問題が発生していないか注意をすること
    - 実行結果が優位となるクエリを採用すること


## 全般について

- 不要なコードは削除する。コメントアウトして残さない

